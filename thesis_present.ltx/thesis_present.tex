\documentclass{beamer}

\setbeamertemplate{navigation symbols}{}

\usepackage[utf8]{inputenc}
\usepackage[english,greek]{babel}
\usepackage{array}

\date{\today}
\author{Δημήτρης Σαριδάκης Μπίτος}
\institute{Εθνικό Μετσόβιο Πολυτεχνείο}

\def\e{\foreignlanguage{english}}
\def\h{\e{Haskell}}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}

\begin{document}

\title{Σχεδίαση και Υλοποίηση της Γλώσσας Προγραμματισμού \e{lambda-cases}}
\frame{\titlepage}

\begin{frame}

\frametitle{Μ' αρέσει πολύ η \h}

Τα πάντα είναι τιμές (όροι) και έχουν κάποιο τύπο:

\begin{itemize}

\item Σταθερές
\item Συναρτήσεις
\item Είσοδος/Έξοδος

% \pause
\begin{itemize}

\item Άρα μπορούν να είναι ορίσματα συναρτήσεων, στοιχεία λίστας κτλ
\\~\
\end{itemize}

\end{itemize}

% \pause
Οι τύποι τα λένε όλα.
\\~\

% \pause
Βοηθητικός μεταγλωττιστής:

\begin{itemize}

\item Μεταγλωττίζεται? Δουλεύει! (Συνήθως)

\item Δεν μεταγλωττίζεται? Οι τάδε τύποι δεν ταιριάζουν.
\\~\

\end{itemize}

% \pause
Γιατί να γράψω κώδικα σε άλλη γλώσσα?

\end{frame}

\begin{frame}

\frametitle{Γιατί δεν είναι η πιο διαδεδομένη γλώσσα?}

\e{Building} εργαλεία όχι τόσο καλά:

\begin{itemize}

\item Φαίνεται να υπάρχει βελτίωση (απ'όσο λένε \e{online})

\item Δεν αφορά την διπλωματική
\\~\

\end{itemize}

% \pause

Δύσκολη στην εκμάθηση για αρχάριο. Ίσως παίζουν ρόλο:

\begin{itemize}

\item Όχι πολύ περιγραφικές λέξεις κλειδιά

\item Όχι πολύ περιγραφικά ονόματα βασικών συναρτήσεων

\item Γραμματική λάμδα λογισμού

\end{itemize}

\end{frame}

\begin{frame}

\frametitle{Τι θα άλλαζα για μένα?}

Μπορούν να συμπτυχθούν κομμάτια που γράφω πολύ συχνά?
\begin{itemize}

\item Ορισμοί Τιμών

\item \e{LambdaCase extension}
\\~\

\end{itemize}

Μπορούν να αλλάξουν κομμάτια ώστε να μοιάζουν περισσότερο στα αντίστοιχα άλλων
γλωσσών όπου είναι πιο κατανοητά?
\begin{itemize}

\item Τελεία για \e{attributes/members/fields}

\item Εφαρμογή συνάρτησης με ορίσματα σε παρένθεση
\\~\

\end{itemize}

Υπάρχει κάτι καινούργιο που θα μπορούσα να προσθέσω?
\begin{itemize}

\item Ορίσματα στην αρχή ή στην μέση του ονόματος της συνάρτησης

\item Ανώνυμες Παράμετροι

\item Τύποι Δύναμης

\end{itemize}

\end{frame}

\begin{frame}[fragile]

\frametitle{Εφαρμογή Συνάρτησης Με Παρενθέσεις}

\begin{otherlanguage}{english}

\begin{center}
\begin{tabular}{ |P{5cm}|P{5cm}| }
 \hline
 Haskell & lcases
 \\
 \hline
 \verb|f x| & \verb|f(x)|
 \\
 \verb|g x y z| & \verb|g(x, y, z)|
 \\
 \verb|putStrLn "Hello World!"| & \verb|print("Hello World!")|
 \\
 \hline
\end{tabular}
\\~\
\\~\
\end{center}

\end{otherlanguage}

% \pause
Ορίσματα πριν ή στην μέση:
\begin{otherlanguage}{english}
\begin{center}
\begin{tabular}{ |P{5cm}|P{5cm}| }
 \hline
 \verb|show x| & \verb|(x)to_string|
 \\
 \verb|mod x y| & \verb|(x)mod(y)|
 \\
 \verb|map f l| & \verb|apply(f)to_all_in(l)|
 \\
 \hline
\end{tabular}
\end{center}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Ανώνυμες Παράμετροι}

Σε οποιαδήποτε συνάρτηση μπορούν να λείπουν οποιαδήποτε από τα ορίσματα:
κάτω παύλα.
\\~\

Τα υπόλοιπα είναι παράμετροι.
\\~\

Νέα συνάρτηση με είσοδο τα κενά ορίσματα.
\begin{otherlanguage}{english}
\begin{center}
\begin{tabular}{ |P{5cm}|P{5cm}| }
 \hline
 \verb|f(_, 1.61, 42)| & \verb|x => f(x, 1.61, 42)|
 \\
 \verb|f(3.14, _, 42)| & \verb|x => f(3.14, x, 42)|
 \\
 \verb|f(_, 1.61, _)| & \verb|(x, y) => f(x, 1.61, y)|
 \\
 \hline
\end{tabular}
\end{center}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Ανώνυμες Παράμετροι}

\begin{otherlanguage}{english}

\begin{verbatim}
greetings : ListOf(String)s
  = ["hey!", "hello!", "hi!"]
\end{verbatim}
\begin{verbatim}
length_of(_) : String => Int
\end{verbatim}
\begin{verbatim}
apply(_)to_all_in(_)
  : (T1 => T2) x ListOf(T1)s => ListOf(T2)s


\end{verbatim}
\begin{verbatim}
apply(length_of(_))to_all_in(_)
  : ListOf(String)s => ListOf(Int)s
\end{verbatim}
\begin{verbatim}
apply(_)to_all_in(greetings)
  : (String => T1) => ListOf(T1)s
\end{verbatim}
\begin{verbatim}
>>> apply(length_of(_))to_all_in(greetings)
  : ListOf(Int)s
  = [4, 6, 3]
\end{verbatim}

\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Το ίδιο σε \h}

\begin{otherlanguage}{english}

\begin{verbatim}
greetings :: [String]
greetings = ["hey!", "hello!", "hi!"]
\end{verbatim}
\begin{verbatim}
length :: String => Int
\end{verbatim}
\begin{verbatim}
map :: (a -> b) -> [a] -> [b]

\end{verbatim}
\begin{verbatim}
map length :: [String] -> [Int]
\end{verbatim}
\begin{verbatim}
flip map :: [a] -> (a -> b) -> [b]
\end{verbatim}
\begin{verbatim}
flip map greetings :: (String -> a) -> [a]
\end{verbatim}
\begin{verbatim}
>>> map length greetings
  = [4, 6, 3]
\end{verbatim}

\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Ανώνυμες Παράμετροι: \e{tuples} και λίστες}

Αντίστοιχα μπορούμε να αφήσουμε κενά στοιχεία \e{tuple} ή λίστας.
\\~\

Νέα συνάρτηση με είσοδο τα κενά στοιχεία.

\begin{otherlanguage}{english}
\begin{verbatim}
(42, _) : T1 => Int x T1

(_, 3.14, _) : T1 x T2 => T1 x Real x T2

[42, _] : Int => ListOf(Int)s

[_, 3.14, _] : Real^2 => ListOf(Real)s

\end{verbatim}
\end{otherlanguage}

Αντίστοιχα σε εκφράσεις τελεστών: παρακάτω.

\end{frame}

\begin{frame}[fragile]

\frametitle{Ορισμοί \e{tuple\_type} και \e{postfix functions}}

\e{tuple\_type} αντίστοιχα:

\begin{itemize}

\item \e{structs} σε \e{C}

\item \e{classes} σε \e{OOP}: μόνο \e{attributes}

\item \e{records} σε \h
\\~\

\end{itemize}

Δημιουργείται αυτόματα ένα \e{postfix function} για κάθε \e{field}:

\begin{itemize}

\item Κατευθείαν με όρισμα:
\begin{otherlanguage}{english}
\verb|some_person.last_name|
\end{otherlanguage}

\item Συνάρτηση Μόνη της:
\begin{otherlanguage}{english}
\verb|_.last_name|
\end{otherlanguage}

\end{itemize}

\end{frame}

\begin{frame}[fragile]

\frametitle{Ορισμοί \e{tuple\_type} και \e{postfix functions}}

\begin{otherlanguage}{english}
\begin{verbatim}
tuple_type Name
value (first_name, last_name) : String^2
\end{verbatim}
% \pause
\begin{verbatim}
awesome_guy: Name
  = ("Leonhard", "Euler")
\end{verbatim}
% \pause
\begin{verbatim}
>>> awesome_guy.last_name
  : String
  = "Euler"
\end{verbatim}
% \pause
\begin{verbatim}
>>> _.last_name
  : Name => String
\end{verbatim}
% \pause
\begin{verbatim}
>>> apply(_.last_name)to_all_in(_)
  : ListOf(Name)s => ListOf(String)s
\end{verbatim}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{\e{postfix functions} για \e{tuples} που έχουν τύπο γινόμενο}

\begin{otherlanguage}{english}
"\verb|_.1st|", "\verb|_.2nd|", "\verb|_.3rd|", ...
\end{otherlanguage}
για \e{tuples} που έχουν τύπο γινόμενο.
\\~\

\begin{otherlanguage}{english}
\begin{verbatim}
tuple : Real x String
  = (1.618, "golden ratio")
\end{verbatim}

\begin{verbatim}
origin : Real^3
  = (0, 0, 0)
\end{verbatim}

\begin{verbatim}
>>> tuple.2nd
  = "golden ratio"
\end{verbatim}

\begin{verbatim}
>>> origin.2nd
  = 0

\end{verbatim}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{\e{".change" postfix function}}

Συναρτήση αλλαγής στοιχείων \e{tuple}

\begin{otherlanguage}{english}
\begin{verbatim}
state.change{counter = counter + 1}
point.change{z = 2.718}

tuples : ListOf(Int^2)s
  = [(1, 2), (3, 4), (5, 6)]
>>> apply(_.change{1st = 1st + 1})to_all_in(tuples)
  = [(2, 2), (4, 4), (6, 6)]

name : Name
  = ("Jacob", "Bernoulli")
change_first_name_to(_) : String => Name
  = name.change{first_name = _}
>>> change_first_name_to("Daniel")
  = ("Daniel", "Bernoulli")
\end{verbatim}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Ορισμοί \e{or\_type} και \e{prefix functions}}

\e{or\_type} αντίστοιχα:

\begin{itemize}

\item \e{C, C++} κτλ: \e{enum types} αλλά πιο γενικά

\item \h:
τα πάντα είναι \e{data}, συμπεριλαμβάνουν \e{tuple types}, \e{or types}
\\~\

\end{itemize}

Οι τιμές τους χωρίζονται σε περιπτώσεις (με ή χωρίς εσωτερικές τιμές).
\\~\

Δημιουργείται αυτόματα ένα \e{prefix function} για κάθε περίπτωση με εσωτερική
τιμή:

\begin{itemize}

\item Κατευθείαν με όρισμα:
\begin{otherlanguage}{english}
\verb|the_value:1|
\end{otherlanguage}

\item Συνάρτηση Μόνη της:
\begin{otherlanguage}{english}
\verb|the_value:_|
\\~\
\end{otherlanguage}

\end{itemize}
\e{Pattern matching} με συνάρτηση \e{"cases"}.

\end{frame}

\begin{frame}[fragile]

\frametitle{Ορισμοί \e{or\_type} και \e{prefix functions}}


\begin{otherlanguage}{english}
\begin{verbatim}
or_type Bool
values true | false

or_type Possibly(T1)
values the_value:T1 | no_value

or_type Result(T1)OrError(T2)
values result:T1 | error:T2

>>> the_value:1
  : Possibly(Int)
>>> the_value:_
  : T1 => Possibly(T1)
>>> result:1
  : Result(Int)OrError(T1)

\end{verbatim}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Τελεστές: Εφαρμογής Συνάρτησης}

\begin{center}
\begin{tabular}{ |P{2cm}|P{5cm}| }
 \hline
 Τελεστής & Τύπος
 \\
 \hline
 \e{\texttt{->}} & \e{\texttt{T1 x (T1 => T2) => T2}}
 \\
 \e{\texttt{<-}} & \e{\texttt{(T1 => T2) x T1 => T2}}
 \\
 \hline
\end{tabular}
\end{center}

Αποφυγή άνοιγματος και κλεισίματος πολλών παρενθέσεων σε αλυσίδα εφαρμογών.
\\~\

Το όρισμα 'μπαίνει' στην συνάρτηση.
\end{frame}

\begin{frame}[fragile]

\frametitle{Τελεστές: Εφαρμογής Συνάρτησης}

\begin{otherlanguage}{english}

\begin{verbatim}
apply(_)to_all_in(_)
  : (T1 => T2) x ListOf(T1)s => ListOf(T2)s
\end{verbatim}
\begin{verbatim}
length_of(_) : String => Int
\end{verbatim}
\begin{verbatim}
filter(_)with(_)
  : ListOf(T1)s x (T1 => Bool) => ListOf(T1)s
\end{verbatim}
\begin{verbatim}
(_)is_odd : Int => Bool
\end{verbatim}
\begin{verbatim}
sum_ints(_) : ListOf(Int)s => Int
\end{verbatim}
\begin{verbatim}
strings : ListOf(String)s
\end{verbatim}
\begin{verbatim}

chars_in_odd_length_strings : Int
  = apply(length_of(_))to_all_in(strings) ->
    filter(_)with((_)is_odd) ->
    sum_ints(_)
\end{verbatim}

\end{otherlanguage}

\end{frame}

\begin{frame}

\frametitle{Τελεστές: Σύνθεσης Συναρτήσεων}

\begin{center}
\begin{tabular}{ |P{2cm}|P{8cm}| }
 \hline
 Τελεστής & Τύπος
 \\
 \hline
 \e{\texttt{o>}} & \e{\texttt{(T1 => T2) x (T2 => T3) => (T1 => T3)}}
 \\
 \e{\texttt{<o}} & \e{\texttt{(T2 => T3) x (T1 => T2) => (T1 => T3)}}
 \\
 \hline
\end{tabular}
\end{center}

Γιατί να γράφεις παραμέτρους όταν μπορείς να κάνεις σύνθεση?
\\~\

Μοιάζουν με σύνθεση στα μαθηματικά.
\\~\

'Δείχνουν' από πρώτη συνάρτηση σε δεύτερη.
\\~\
\end{frame}

\begin{frame}[fragile]

\frametitle{Τελεστές: Σύνθεσης Συναρτήσεων}

\begin{otherlanguage}{english}
\begin{verbatim}
split(_)to_words : String => ListOf(String)s

apply(_)to_all_in(_)
  : (T1 => T2) x ListOf(T1)s => ListOf(T2)s

reverse_str(_) : String => String

merge_words(_) : ListOf(String)s => String


reverse_words_in(_) : String => String
  = split(_)to_words o>
    apply(reverse_str(_))to_all_in(_) o>
    merge_words(_)
\end{verbatim}
\end{otherlanguage}

\end{frame}

\begin{frame}

\frametitle{Τελεστές: Αριθμητικοί}

\begin{center}
\begin{tabular}{ |P{1.5cm}|P{8.9cm}| }
 \hline
 Τελεστής & Τύπος
 \\
 \hline
 \e{\texttt{\^}} & \e{\texttt{(@A)To\_The(@B)Is(@C) --> @A x @B => @C}}
 \\
 \e{\texttt{*}} & \e{\texttt{(@A)And(@B)Multiply\_To(@C) --> @A x @B => @C}}
 \\
 \e{\texttt{/}} & \e{\texttt{(@A)Divided\_By(@B)Is(@C) --> @A x @B => @C}}
 \\
 \e{\texttt{+}} & \e{\texttt{(@A)And(@B)Add\_To(@C) --> @A x @B => @C}}
 \\
 \e{\texttt{-}} & \e{\texttt{(@A)Minus(@B)Is(@C) --> @A x @B => @C}}
 \\
 \hline
\end{tabular}
\end{center}

Ότι περιμένει κανείς για τους στάνταρ τύπους.
\\~\

Γενικευμένοι για κόλπα \e{python} (κρατώντας την σιγουριά τύπων!).
\\~\

\end{frame}

\begin{frame}[fragile]

\frametitle{Τελεστές: Αριθμητικοί}

\begin{otherlanguage}{english}
\begin{verbatim}
>>> 'a' + 'b'
  = "ab"
>>> 'w' + "ord"
  = "word"
>>> "Hello " + "World!"
  : String
  = "Hello World!"
>>> 5 * 'a'
  : String
  = "aaaaa"
>>> 5 * "hi"
  : String
  = "hihihihihi"
>>> "1,2,3" - ','
  : String
  = "123"
\end{verbatim}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Τελεστές: Σχεσιακοί και Λογικοί}

\begin{center}
\begin{tabular}{ |P{0.8cm}|P{9.4cm}| }
 \hline
 \e{Op} & Τύπος
 \\
 \hline
 \e{\texttt{==}} & \e{\texttt{(@A)And(@B)Can\_Be\_Equal --> @A x @B => Bool}}
 \\
 \e{\texttt{!=}} & \e{\texttt{(@A)And(@B)Can\_Be\_Unequal --> @A x @B => Bool}}
 \\
 \e{\texttt{>}} & \e{\texttt{(@A)Can\_Be\_Greater\_Than(@B) --> @A x @B => Bool}}
 \\
 \e{\texttt{<}} & \e{\texttt{(@A)Can\_Be\_Less\_Than(@B) --> @A x @B => Bool}}
 \\
 \e{\texttt{>=}} & \e{\texttt{(@A)Can\_Be\_Gr\_Or\_Eq\_To(@B) --> @A x @B => Bool}}
 \\
 \e{\texttt{<=}} & \e{\texttt{(@A)Can\_Be\_Le\_Or\_Eq\_To(@B) --> @A x @B => Bool}}
 \\
 \e{\texttt{\&}} & \e{\texttt{(@A)Has\_And --> @A}\texttt{\^}\texttt{2 => @A}}
 \\
 \e{\texttt{|}} & \e{\texttt{(@A)Has\_Or --> @A}\texttt{\^}\texttt{2 => @A}}
 \\
 \hline
\end{tabular}
\end{center}

Μπορούν να συγκριθούν διαφορετικοί τύποι.
\\~\

Τελεστές 'και' και 'ή' πολυμορφικοί για να χρησιμοποιούνται και για
\e{bitwise operations}.
\\~\

\e{todo slide} με παραδείγματα
\end{frame}

\begin{frame}

\frametitle{Τελεστές: Περιβάλλοντος}

\begin{center}
\begin{tabular}{ |P{0.4cm}|P{9.9cm}| }
 \hline
 \e{Op} & Τύπος
 \\
 \hline
 \e{\texttt{;>}} & \e{\texttt{(@E)Has\_Use --> @E(T1) x (T1 => @E(T2)) => @E(T2)}}
 \\
 \e{\texttt{;}} & \e{\texttt{(@E)Has\_Then --> @E(T1) x @E(T2) => @E(T2)}}
 \\
 \hline
\end{tabular}
\\~\
\\~\
\end{center}

Για συνδιασμούς δράσεων σε περιβάλλον (\e{IO, State} κτλ).
\\~\

Αντιστοιχούν στους \e{operators "bind"} και \e{"then"} των \e{Monads}.

\end{frame}

\begin{frame}[fragile]

\frametitle{Τελεστές: Περιβάλλοντος}

\begin{otherlanguage}{english}
\begin{verbatim}
main: (EmptyVal)FromIO
  = print("I'll repeat the line") ; get_line ;> print(_)
\end{verbatim}
\end{otherlanguage}
κτλ

slide με ανώνυμη παράμετρο σε έκφραση τελεστών 42 κτλ
\end{frame}

\begin{frame}[fragile]

\frametitle{Εκφράσεις Συναρτήσεων}

\begin{otherlanguage}{english}
\begin{verbatim}
a => 17 * a + 42
(x, y, z) => sqrt(x^2 + y^2 + z^2)
\end{verbatim}
\end{otherlanguage}
Αστερίσκος για παραμέτρους που δεν έχουν σημασία
\begin{otherlanguage}{english}
\begin{verbatim}
* => 42
(x, *, z) => x + z
\end{verbatim}
\end{otherlanguage}
\e{Matching} σε παραμέτρους \e{tuples}
\begin{otherlanguage}{english}
\begin{verbatim}
((x1, y1), (x2, y2)) => (x1 + x2, y1 + y2)
\end{verbatim}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Εκφράσεις Συναρτήσεων \e{"cases"}}

\begin{otherlanguage}{english}
\begin{verbatim}
(_)is_forty_two: Int => Bool
  = cases
    42 => true
    ... => false

gcd_of(_)and(_): Int^2 => Int
  = (x, cases)
    0 => x
    y => gcd_of(y)and((x)mod(y))

traffic_lights_match(_, _): TrafficLight^2 => Bool
  = (cases, cases)
    (green, green) => true
    (amber, amber) => true
    (red, red) => true
    ... => false
\end{verbatim}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Εκφράσεις Συναρτήσεων \e{"cases"}}

\begin{otherlanguage}{english}
\begin{verbatim}
apply(_)to_all_in(_)
  : (T1 => T2) x ListOf(T1)s => ListOf(T2)s
  = (f(_), cases)
    [] => []
    [head, tail = ...] =>
      f(head) + apply(f(_))to_all_in(tail)

(_)is_sorted: ListOf(Int)s => Bool
  = cases
    [x1, x2, xs = ...] => (x1 <= x2) & (x2 + xs)is_sorted
    ... => true
\end{verbatim}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Ορισμοί Τιμών}

\begin{otherlanguage}{english}
\begin{verbatim}
foo: Int
  = 1
\end{verbatim}
\end{otherlanguage}
Ομαδοποίηση ορισμών:
\begin{otherlanguage}{english}
\begin{verbatim}
val1, val2, val3: Int, Bool, Char
  = 2, true, 'a'
\end{verbatim}
\end{otherlanguage}
Λέξη κλειδί \e{"all"}:
\begin{otherlanguage}{english}
\begin{verbatim}
int1, int2, int3: all Int
  = 1, 2, 3
\end{verbatim}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Εκφράσεις με \e{"where"}}

\begin{otherlanguage}{english}
\begin{verbatim}
sort(_): ListOf(Int)s => ListOf(Int)s
  = cases
    [] => []
    [head, tail = ...] =>
      sort(less_l) + head + sort(greater_l)
      where
      less_l, greater_l: all ListOf(Int)s
        = filter(tail)with(_ <= head)
        , filter(tail)with(_ > head)
\end{verbatim}
\end{otherlanguage}

\end{frame}

\begin{frame}

\frametitle{Τύποι}

\begin{center}
\begin{tabular}{ |M{2.5cm}|M{3cm}|M{4.3cm}| }
 \hline
 & \e{lcases} & \h
 \\
 \hline
 Παραμετρικές μεταβλητές τύπων & T1 T2 T3 & \e{a b c}
 \\
 \hline
 \e{Ad hoc} μεταβλητές τύπων & \e{@A @B @C} & \e{a b c}
 \\
 \hline
 Τύποι εφαρμογής συνάρτησης τύπου & \e{Possibly(Int)} & \e{Maybe Int}
 \\
 \hline
 Τύποι γινόμενα & \e{Int x Real x String} & \e{(Int, Double, String)}
 \\
 \hline
 Τύποι δύναμης & \e{\texttt{Int\^}}\e{3} & \e{(Int, Int, Int)}
 \\
 \hline
 Τύποι συνάρτησης & \e{\texttt{Int => Int}} & \e{\texttt{Int -> Int}}
 \\
 \hline
\end{tabular}
\end{center}

\end{frame}

\begin{frame}[fragile]

\frametitle{Τύποι με προϋπόθεση}

\begin{otherlanguage}{english}
\begin{verbatim}
(@A)And(@B)Add_To(@C) --> @A x @B => @C

(@A)Is(@B)s_First --> @B => @A

(@E)Has_Use --> @E(T1) x (T1 => @E(T2)) => @E(T2)

\end{verbatim}
\h
\begin{verbatim}
Add a b c => a -> b -> c

Show a => a -> String

Monad m => m a -> (a -> m b) -> m b
\end{verbatim}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Πατσούκλια Τύπων}

\begin{otherlanguage}{english}
\begin{verbatim}
type_nickname Ints = ListOf(Int)s
type_nickname IntStringPairs = ListOf(Int x String)s
type_nickname IO = (EmptyVal)FromIO
type_nickname Res(T1)OrErr = Result(T1)OrError(String)

\end{verbatim}
\end{otherlanguage}

\e{type} στην \h

\end{frame}

\begin{frame}

\frametitle{Λογική Τύπων}

Μηχανισμός \e{ad hoc} πολυμορφισμού στην \e{lcases}.
\\~\

Αντιστοιχεί στα \e{type classes (MultiParamTypeClasses extension)}.

\end{frame}

\begin{frame}

\frametitle{Ορισμοί Προτάσεων Τύπων}

Ατομικές, \e{class}
\\~\

Μετονομασίας

\end{frame}

\begin{frame}

\frametitle{Θεωρήματα Τύπων}

\e{instance}

\end{frame}

\begin{frame}

\frametitle{Υλοποίηση \e{Parser}}

Βιβλιοθήκη \e{Parsec}

\end{frame}

\begin{frame}

\frametitle{Μετάφραση σε \h}

\end{frame}

\begin{frame}

\frametitle{Συμπεράσματα}

Τι έχει γίνει
\\~\

Τι θα ήταν καλό να γίνει

\end{frame}

\end{document}
