\documentclass{beamer}

\setbeamertemplate{navigation symbols}{}

\usepackage[utf8]{inputenc}
\usepackage[english,greek]{babel}
\usepackage{array}

\date{\today}
\author{Δημήτρης Σαριδάκης Μπίτος}
\institute{Εθνικό Μετσόβιο Πολυτεχνείο}

\def\e{\foreignlanguage{english}}
\def\h{\e{Haskell}}
%\newcommand\_[_]{_}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}

\begin{document}

\title{Σχεδίαση και Υλοποίηση της Γλώσσας Προγραμματισμού \e{lambda-cases}}
\frame{\titlepage}

\begin{frame}

\frametitle{Μ' αρέσει πολύ η \h}

Τα πάντα είναι τιμές (όροι) και έχουν κάποιο τύπο:

\begin{itemize}

\item Σταθερές
\item Συναρτήσεις
\item Είσοδος/Έξοδος

% \pause
\begin{itemize}

\item Άρα μπορούν να είναι ορίσματα συναρτήσεων, στοιχεία λίστας κτλ
\\~\
\end{itemize}

\end{itemize}

% \pause
Οι τύποι τα λένε όλα.
\\~\

% \pause
Βοηθητικός μεταγλωττιστής:

\begin{itemize}

\item Μεταγλωττίζεται? Δουλεύει! (Συνήθως)

\item Δεν μεταγλωττίζεται? Οι τάδε τύποι δεν ταιριάζουν.
\\~\

\end{itemize}

% \pause
Γιατί να γράψω κώδικα σε άλλη γλώσσα?

\end{frame}

\begin{frame}

\frametitle{Γιατί δεν είναι η πιο διαδεδομένη γλώσσα?}

\e{Building} εργαλεία όχι τόσο καλά:

\begin{itemize}

\item Φαίνεται να υπάρχει βελτίωση (απ'όσο λένε \e{online})

\item Δεν αφορά την διπλωματική
\\~\

\end{itemize}

% \pause

Δύσκολη στην εκμάθηση για αρχάριο. Ίσως παίζουν ρόλο:

\begin{itemize}

\item Όχι πολύ περιγραφικές λέξεις κλειδιά

\item Όχι πολύ περιγραφικά ονόματα βασικών συναρτήσεων

\item Γραμματική λάμδα λογισμού

\end{itemize}

\end{frame}

\begin{frame}

\frametitle{Τι θα άλλαζα για μένα?}

Μπορούν να συμπτυχθούν κομμάτια που γράφω πολύ συχνά?
\begin{itemize}

\item Ορισμοί Τιμών

\item \e{LambdaCase extension}
\\~\

\end{itemize}

Μπορούν να αλλάξουν κομμάτια ώστε να μοιάζουν περισσότερο στα αντίστοιχα άλλων
γλωσσών όπου είναι πιο κατανοητά?
\begin{itemize}

\item Τελεία για \e{attributes/members/fields}

\item Εφαρμογή συνάρτησης με ορίσματα σε παρένθεση
\\~\

\end{itemize}

Υπάρχει κάτι καινούργιο που θα μπορούσα να προσθέσω?
\begin{itemize}

\item Ορίσματα στην αρχή ή στην μέση του ονόματος της συνάρτησης

\item Ανώνυμες Παράμετροι

\item Τύποι Δύναμης

\end{itemize}

\end{frame}

\begin{frame}[fragile]

\frametitle{Εφαρμογή Συνάρτησης Με Παρενθέσεις}

\begin{otherlanguage}{english}

\begin{center}
\begin{tabular}{ |P{5cm}|P{5cm}| }
 \hline
 Haskell & lcases
 \\
 \hline
 \verb|f x| & \verb|f(x)|
 \\
 \verb|g x y z| & \verb|g(x, y, z)|
 \\
 \verb|putStrLn "Hello World!"| & \verb|print("Hello World!")|
 \\
 \hline
\end{tabular}
\\~\
\\~\
\end{center}

\end{otherlanguage}

% \pause
Ορίσματα πριν ή στην μέση:
\begin{otherlanguage}{english}
\begin{center}
\begin{tabular}{ |P{5cm}|P{5cm}| }
 \hline
 \verb|show x| & \verb|(x)to_string|
 \\
 \verb|mod x y| & \verb|(x)mod(y)|
 \\
 \verb|map f l| & \verb|apply(f)to_all_in(l)|
 \\
 \hline
\end{tabular}
\end{center}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Ανώνυμες Παράμετροι}

Σε οποιαδήποτε συνάρτηση μπορούν να λείπουν οποιαδήποτε από τα ορίσματα:
κάτω παύλα.
\\~\

Τα υπόλοιπα είναι παράμετροι.
\\~\

Νέα συνάρτηση με είσοδο τα κενά ορίσματα.
\begin{otherlanguage}{english}
\begin{center}
\begin{tabular}{ |P{5cm}|P{5cm}| }
 \hline
 \verb|f(_, 1.61, 42)| & \verb|x => f(x, 1.61, 42)|
 \\
 \verb|f(3.14, _, 42)| & \verb|x => f(3.14, x, 42)|
 \\
 \verb|f(_, 1.61, _)| & \verb|(x, y) => f(x, 1.61, y)|
 \\
 \hline
\end{tabular}
\end{center}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Ανώνυμες Παράμετροι}

\begin{otherlanguage}{english}

\begin{verbatim}
greetings : ListOf(String)s
  = ["hey!", "hello!", "hi!"]
\end{verbatim}
\begin{verbatim}
length_of(_) : String => Int
\end{verbatim}
\begin{verbatim}
apply(_)to_all_in(_)
  : (T1 => T2) x ListOf(T1)s => ListOf(T2)s


\end{verbatim}
\begin{verbatim}
apply(length_of(_))to_all_in(_)
  : ListOf(String)s => ListOf(Int)s
\end{verbatim}
\begin{verbatim}
apply(_)to_all_in(greetings)
  : (String => T1) => ListOf(T1)s
\end{verbatim}
\begin{verbatim}
>>> apply(length_of(_))to_all_in(greetings)
  : ListOf(Int)s
  = [4, 6, 3]
\end{verbatim}

\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Το ίδιο σε \h}

\begin{otherlanguage}{english}

\begin{verbatim}
greetings :: [String]
greetings = ["hey!", "hello!", "hi!"]
\end{verbatim}
\begin{verbatim}
length :: String => Int
\end{verbatim}
\begin{verbatim}
map :: (a -> b) -> [a] -> [b]

\end{verbatim}
\begin{verbatim}
map length :: [String] -> [Int]
\end{verbatim}
\begin{verbatim}
flip map :: [a] -> (a -> b) -> [b]
\end{verbatim}
\begin{verbatim}
flip map greetings :: (String -> a) -> [a]
\end{verbatim}
\begin{verbatim}
>>> map length greetings
  = [4, 6, 3]
\end{verbatim}

\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Ανώνυμες Παράμετροι: \e{tuples} και λίστες}

Αντίστοιχα μπορούμε να αφήσουμε κενά στοιχεία \e{tuple} ή λίστας.
\\~\

Νέα συνάρτηση με είσοδο τα κενά στοιχεία.

\begin{otherlanguage}{english}
\begin{verbatim}
(42, _) : T1 => Int x T1

(_, 3.14, _) : T1 x T2 => T1 x Real x T2

[42, _] : Int => ListOf(Int)s

[_, 3.14, _] : Real^2 => ListOf(Real)s

\end{verbatim}
\end{otherlanguage}

Αντίστοιχα σε εκφράσεις τελεστών: παρακάτω.

\end{frame}

\begin{frame}[fragile]

\frametitle{Ορισμοί \e{tuple\_type} και \e{postfix functions}}

\e{tuple\_type} αντίστοιχα:

\begin{itemize}

\item \e{structs} σε \e{C}

\item \e{classes} σε \e{OOP}: μόνο \e{attributes}

\item \e{records} σε \h
\\~\

\end{itemize}

Δημιουργείται αυτόματα ένα \e{postfix function} για κάθε \e{field}:

\begin{itemize}

\item Κατευθείαν με όρισμα:
\begin{otherlanguage}{english}
\verb|some_person.last_name|
\end{otherlanguage}

\item Συνάρτηση Μόνη της:
\begin{otherlanguage}{english}
\verb|_.last_name|
\end{otherlanguage}

\end{itemize}

\end{frame}

\begin{frame}[fragile]

\frametitle{Ορισμοί \e{tuple\_type} και \e{postfix functions}}

\begin{otherlanguage}{english}
\begin{verbatim}
tuple_type Name
value (first_name, last_name) : String^2
\end{verbatim}
% \pause
\begin{verbatim}
awesome_guy: Name
  = ("Leonhard", "Euler")
\end{verbatim}
% \pause
\begin{verbatim}
>>> awesome_guy.last_name
  : String
  = "Euler"
\end{verbatim}
% \pause
\begin{verbatim}
>>> _.last_name
  : Name => String
\end{verbatim}
% \pause
\begin{verbatim}
>>> apply(_.last_name)to_all_in(_)
  : ListOf(Name)s => ListOf(String)s
\end{verbatim}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{\e{postfix functions} για \e{tuples} που έχουν τύπο γινόμενο}

\begin{otherlanguage}{english}
"\verb|_.1st|", "\verb|_.2nd|", "\verb|_.3rd|", ...
\end{otherlanguage}
για \e{tuples} που έχουν τύπο γινόμενο.
\\~\

\begin{otherlanguage}{english}
\begin{verbatim}
tuple : Real x String
  = (1.618, "golden ratio")
\end{verbatim}

\begin{verbatim}
origin : Real^3
  = (0, 0, 0)
\end{verbatim}

\begin{verbatim}
>>> tuple.2nd
  = "golden ratio"
\end{verbatim}

\begin{verbatim}
>>> origin.2nd
  = 0

\end{verbatim}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{\e{".change" postfix function}}

Συναρτήση αλλαγής στοιχείων \e{tuple}

\begin{otherlanguage}{english}
\begin{verbatim}
state.change{counter = counter + 1}
point.change{z = 2.718}

tuples : ListOf(Int^2)s
  = [(1, 2), (3, 4), (5, 6)]
>>> apply(_.change{1st = 1st + 1})to_all_in(tuples)
  = [(2, 2), (4, 4), (6, 6)]

name : Name
  = ("Jacob", "Bernoulli")
change_first_name_to(_) : String => Name
  = name.change{first_name = _}
>>> change_first_name_to("Daniel")
  = ("Daniel", "Bernoulli")
\end{verbatim}
\end{otherlanguage}

\end{frame}

\begin{frame}[fragile]

\frametitle{Ορισμοί \e{or\_type} και \e{prefix functions}}

\e{or\_type} αντίστοιχα:

\begin{itemize}

\item \e{C, C++} κτλ: \e{enum types} αλλά πιο γενικά

\item \h:
τα πάντα είναι \e{data}, συμπεριλαμβάνουν \e{tuple types}, \e{or types}
\\~\

\end{itemize}

Οι τιμές τους χωρίζονται σε περιπτώσεις (με ή χωρίς εσωτερικές τιμές).
\\~\

Δημιουργείται αυτόματα ένα \e{prefix function} για κάθε περίπτωση με εσωτερική
τιμή:

\begin{itemize}

\item Κατευθείαν με όρισμα:
\begin{otherlanguage}{english}
\verb|the_value:1|
\end{otherlanguage}

\item Συνάρτηση Μόνη της:
\begin{otherlanguage}{english}
\verb|the_value:_|
\\~\
\end{otherlanguage}

\end{itemize}
\e{Pattern matching} με συνάρτηση \e{"cases"}.

\end{frame}

\begin{frame}[fragile]

\frametitle{Ορισμοί \e{or\_type} και \e{prefix functions}}


\begin{otherlanguage}{english}
\begin{verbatim}
or_type Bool
values true | false

or_type Possibly(T1)
values the_value:T1 | no_value

or_type Result(T1)OrError(T2)
values result:T1 | error:T2

>>> the_value:1
  : Possibly(Int)
>>> the_value:_
  : T1 => Possibly(T1)
>>> result:1
  : Result(Int)OrError(T1)

\end{verbatim}
\end{otherlanguage}

\end{frame}

\begin{frame}

\frametitle{Τελεστές: Εφαρμογής Συνάρτησης}

\end{frame}

\begin{frame}

\frametitle{Τελεστές: Σύνθεσης Συναρτήσεων}

\end{frame}

\begin{frame}

\frametitle{Τελεστές: Αριθμητικοί}

\end{frame}

\begin{frame}

\frametitle{Τελεστές: Σχεσιακοί και Λογικοί}

\end{frame}

\begin{frame}

\frametitle{Τελεστές: Περιβάλλοντος}

\end{frame}

\begin{frame}

\frametitle{Εκφράσεις Συναρτήσεων}

\end{frame}

\begin{frame}

\frametitle{Εκφράσεις Συναρτήσεων \e{"cases"}}

\e{pattern matching}
\\~\

\e{LambdaCase extension}

\end{frame}

\begin{frame}

\frametitle{Ορισμοί Τιμών}

Σύγκριση με \h

\end{frame}

\begin{frame}

\frametitle{Εκφράσεις \e{"where"}}
Παραδείγματα

\end{frame}

\begin{frame}

\frametitle{Τύποι}

Αντιστοιχία με \h

\end{frame}

\begin{frame}

\frametitle{Πατσούκλια Τύπων}

\e{type} στην \h
\\~\

Παραδείγματα

\end{frame}

\begin{frame}

\frametitle{Λογική Τύπων}

Μηχανισμός \e{ad hoc} πολυμορφισμού στην \e{lcases}.
\\~\

Αντιστοιχοί στα \e{type classes}.

\end{frame}

\begin{frame}

\frametitle{Ορισμοί Προτάσεων Τύπων}

Ατομικές, \e{class}
\\~\

Μετονομασίας

\end{frame}

\begin{frame}

\frametitle{Θεωρήματα Τύπων}

\e{instance}

\end{frame}

\begin{frame}

\frametitle{Υλοποίηση \e{Parser}}

Βιβλιοθήκη \e{Parsec}

\end{frame}

\begin{frame}

\frametitle{Μετάφραση σε \h}

\end{frame}

\begin{frame}

\frametitle{Συμπεράσματα}

Τι έχει γίνει
\\~\

Τι θα ήταν καλό να γίνει

\end{frame}

\end{document}
